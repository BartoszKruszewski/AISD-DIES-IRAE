# Zadanie 1

Operacja succ(x) nie jest specjalnie wspierana przez powyższe struktury danych, więc żeby znaleźć następnik należałoby przeszukać wszystkie elementy, co można zrobić w czasie O(n).

# Zadanie 2

$T(n) = T(\sqrt{n}) + O(1)$

Załóżmy, że $n = 2^{2^k}$

$T(n) = T(\sqrt{2^{2^k}}) + O(1) = T(2^{2^{k - 1}}) + O(1) = T(2^{2^0}) + k * O(1) = T(2) + O(k) = O(k)$

Wiemy, że $n = 2^{2^k}$, więc $log_2{n} = 2^k$, więc $log_2{log_2{n}} = k$, więc $T(n) = O(log_2{log_2{n}})$

# Zadanie 6

Tak, drzewa splay odnoszą się jedynie do operacji słownikowych, natomiast nie mają żadnego warunku dla struktury drzewa. Jedyny warunek jaki musi być spełniony to drzewo musi być BST.

# Zadanie 7

# Zadanie 8

Shift-AND wykorzystuje dużo operacji na bitach, dlatego działa bardzo efektywnie dla wzorców, których zapis bitowy nie przekracza długości słowa bitowego, wtedy czas działania operacji bitowych można potraktować jako stałą.

# Zadanie 10

Funkcja $\pi(k) = x$ oznacza długość najdłuższego prefiksu w prefiksie wzorca o długośći k, który jest jednocześnie sufiksem. Prefiks nie może być całym wzorcem.

$(ab)^k$ oznacza $ab$ powtórzone $k$ razy. Więc najdłuszym prefiksem będzie (ab)^{k-1}, którego długość to $2k - 2$, czyli $2k - 2$ będzie maksymalną wartością.

# Zadanie 11

W algorytmie Kruskala użycie kolejki priorytetowej miałoby sens do sortowania krawedzi wzgledem wag. Tutaj otrzymujemy jako dane posortowane krawedzeniem, wiec w ogole nie musimy uzywac kolejki. Zamiast kolejki do szybkiej implementacji tego algorytmu można użyć struktury UNION-FIND, wtedy złożoność wyniesie $O(E * log^*{V})$.

# Zadanie 12
